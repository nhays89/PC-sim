\hypertarget{assembler_8h}{}\section{assembler.\+h File Reference}
\label{assembler_8h}\index{assembler.\+h@{assembler.\+h}}


Assembles strings of assembly code to integers representing binary machine code.  


\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
char \hyperlink{assembler_8h_ac8a99ffcd03a49df1c320d6156627449}{get\+Instruction\+Type} (int instr)
\begin{DoxyCompactList}\small\item\em Determines the type of instruction in an instruction. based on the binary of the opcode. \end{DoxyCompactList}\item 
int \hyperlink{assembler_8h_ae1f1e62a268f0105396db6502f21a03b}{is\+Directive} (char $\ast$inst)
\begin{DoxyCompactList}\small\item\em Sees if a line is a assembler directive by checking if the first character in the line is a \textquotesingle{}.\textquotesingle{}. \end{DoxyCompactList}\item 
int \hyperlink{assembler_8h_a951de30b8d3982928a6c8da4d065f2eb}{create\+Machine\+Code} (char $\ast$inst)
\begin{DoxyCompactList}\small\item\em takes a string representing an instruction and returns an integer with the correct binary representation of the machine code of the instuction string. \end{DoxyCompactList}\item 
void \hyperlink{assembler_8h_aec33dd350c747ca07f3b69118317a9a2}{set\+Immediate} (int $\ast$instr, char $\ast$imm)
\begin{DoxyCompactList}\small\item\em Adds an immidate value to an I instruction. \end{DoxyCompactList}\item 
void \hyperlink{assembler_8h_a11814c3e23fdc2336183c6e24b48fed6}{set\+Register} (char reg\+To\+Set, int $\ast$instr, char $\ast$reg\+Name)
\begin{DoxyCompactList}\small\item\em fills in the binary operand of a register number in an instruction \end{DoxyCompactList}\item 
int \hyperlink{assembler_8h_a4ea64401ea1d6138a1a640c7c83a0cd7}{get\+Opcode} (char $\ast$instr)
\begin{DoxyCompactList}\small\item\em returns an int containg the opcode for an instruction (opcode in the most sig 4 bits) \end{DoxyCompactList}\item 
int \hyperlink{assembler_8h_ac20c50d0b0ffda757952a7ee60018943}{get\+Register\+Num} (char $\ast$reg)
\begin{DoxyCompactList}\small\item\em Gets the base 10 number of a register based on it\textquotesingle{}s string representation. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Assembles strings of assembly code to integers representing binary machine code. 

\begin{DoxyAuthor}{Author}
nnebp 
\end{DoxyAuthor}


\subsection{Function Documentation}
\index{assembler.\+h@{assembler.\+h}!create\+Machine\+Code@{create\+Machine\+Code}}
\index{create\+Machine\+Code@{create\+Machine\+Code}!assembler.\+h@{assembler.\+h}}
\subsubsection[{\texorpdfstring{create\+Machine\+Code(char $\ast$inst)}{createMachineCode(char *inst)}}]{\setlength{\rightskip}{0pt plus 5cm}int create\+Machine\+Code (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{inst}
\end{DoxyParamCaption}
)}\hypertarget{assembler_8h_a951de30b8d3982928a6c8da4d065f2eb}{}\label{assembler_8h_a951de30b8d3982928a6c8da4d065f2eb}


takes a string representing an instruction and returns an integer with the correct binary representation of the machine code of the instuction string. 


\begin{DoxyParams}{Parameters}
{\em inst} & string instruction. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
machine code representation of instruction. 
\end{DoxyReturn}
\index{assembler.\+h@{assembler.\+h}!get\+Instruction\+Type@{get\+Instruction\+Type}}
\index{get\+Instruction\+Type@{get\+Instruction\+Type}!assembler.\+h@{assembler.\+h}}
\subsubsection[{\texorpdfstring{get\+Instruction\+Type(int instr)}{getInstructionType(int instr)}}]{\setlength{\rightskip}{0pt plus 5cm}char get\+Instruction\+Type (
\begin{DoxyParamCaption}
\item[{int}]{instr}
\end{DoxyParamCaption}
)}\hypertarget{assembler_8h_ac8a99ffcd03a49df1c320d6156627449}{}\label{assembler_8h_ac8a99ffcd03a49df1c320d6156627449}


Determines the type of instruction in an instruction. based on the binary of the opcode. 


\begin{DoxyParams}{Parameters}
{\em instr} & a binary instruction. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Character representing the instruction type (R,I,J,O). 
\end{DoxyReturn}
\index{assembler.\+h@{assembler.\+h}!get\+Opcode@{get\+Opcode}}
\index{get\+Opcode@{get\+Opcode}!assembler.\+h@{assembler.\+h}}
\subsubsection[{\texorpdfstring{get\+Opcode(char $\ast$instr)}{getOpcode(char *instr)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Opcode (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{instr}
\end{DoxyParamCaption}
)}\hypertarget{assembler_8h_a4ea64401ea1d6138a1a640c7c83a0cd7}{}\label{assembler_8h_a4ea64401ea1d6138a1a640c7c83a0cd7}


returns an int containg the opcode for an instruction (opcode in the most sig 4 bits) 


\begin{DoxyParams}{Parameters}
{\em instr} & the text of an instruction (line from .asm file) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
binary representing an instruction with the opcode bits set. 
\end{DoxyReturn}
\index{assembler.\+h@{assembler.\+h}!get\+Register\+Num@{get\+Register\+Num}}
\index{get\+Register\+Num@{get\+Register\+Num}!assembler.\+h@{assembler.\+h}}
\subsubsection[{\texorpdfstring{get\+Register\+Num(char $\ast$reg)}{getRegisterNum(char *reg)}}]{\setlength{\rightskip}{0pt plus 5cm}int get\+Register\+Num (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{reg}
\end{DoxyParamCaption}
)}\hypertarget{assembler_8h_ac20c50d0b0ffda757952a7ee60018943}{}\label{assembler_8h_ac20c50d0b0ffda757952a7ee60018943}


Gets the base 10 number of a register based on it\textquotesingle{}s string representation. 


\begin{DoxyParams}{Parameters}
{\em reg} & the ascii name of a register \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
an int containg the dec number (0-\/15) or a register 
\end{DoxyReturn}
\index{assembler.\+h@{assembler.\+h}!is\+Directive@{is\+Directive}}
\index{is\+Directive@{is\+Directive}!assembler.\+h@{assembler.\+h}}
\subsubsection[{\texorpdfstring{is\+Directive(char $\ast$inst)}{isDirective(char *inst)}}]{\setlength{\rightskip}{0pt plus 5cm}int is\+Directive (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{inst}
\end{DoxyParamCaption}
)}\hypertarget{assembler_8h_ae1f1e62a268f0105396db6502f21a03b}{}\label{assembler_8h_ae1f1e62a268f0105396db6502f21a03b}


Sees if a line is a assembler directive by checking if the first character in the line is a \textquotesingle{}.\textquotesingle{}. 


\begin{DoxyParams}{Parameters}
{\em inst} & string representing an instruction \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if the string is not a directive 1 if it is. 
\end{DoxyReturn}
\index{assembler.\+h@{assembler.\+h}!set\+Immediate@{set\+Immediate}}
\index{set\+Immediate@{set\+Immediate}!assembler.\+h@{assembler.\+h}}
\subsubsection[{\texorpdfstring{set\+Immediate(int $\ast$instr, char $\ast$imm)}{setImmediate(int *instr, char *imm)}}]{\setlength{\rightskip}{0pt plus 5cm}void set\+Immediate (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{instr, }
\item[{char $\ast$}]{imm}
\end{DoxyParamCaption}
)}\hypertarget{assembler_8h_aec33dd350c747ca07f3b69118317a9a2}{}\label{assembler_8h_aec33dd350c747ca07f3b69118317a9a2}


Adds an immidate value to an I instruction. 


\begin{DoxyParams}{Parameters}
{\em instr} & a binary instruction \\
\hline
{\em imm} & string with base 10 immidate value \\
\hline
\end{DoxyParams}
\index{assembler.\+h@{assembler.\+h}!set\+Register@{set\+Register}}
\index{set\+Register@{set\+Register}!assembler.\+h@{assembler.\+h}}
\subsubsection[{\texorpdfstring{set\+Register(char reg\+To\+Set, int $\ast$instr, char $\ast$reg\+Name)}{setRegister(char regToSet, int *instr, char *regName)}}]{\setlength{\rightskip}{0pt plus 5cm}void set\+Register (
\begin{DoxyParamCaption}
\item[{char}]{reg\+To\+Set, }
\item[{int $\ast$}]{instr, }
\item[{char $\ast$}]{reg\+Name}
\end{DoxyParamCaption}
)}\hypertarget{assembler_8h_a11814c3e23fdc2336183c6e24b48fed6}{}\label{assembler_8h_a11814c3e23fdc2336183c6e24b48fed6}


fills in the binary operand of a register number in an instruction 


\begin{DoxyParams}{Parameters}
{\em instr} & pointer to the binary instruction we are creating \\
\hline
{\em reg\+To\+Set} & the register operand to set (x,y or z) (ex\+: add X,Y,Z or addi X,Y, 42) \\
\hline
{\em reg\+Name} & the ascii name of the register to be used as an operand (ex\+: \$a0) \\
\hline
\end{DoxyParams}
